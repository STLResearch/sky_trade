// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tracking_authorization_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TrackingAuthorizationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkTrackingStatus,
    required TResult Function() requestTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkTrackingStatus,
    TResult? Function()? requestTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkTrackingStatus,
    TResult Function()? requestTracking,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CheckTrackingStatus value) checkTrackingStatus,
    required TResult Function(_RequestTracking value) requestTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult? Function(_RequestTracking value)? requestTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult Function(_RequestTracking value)? requestTracking,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrackingAuthorizationEventCopyWith<$Res> {
  factory $TrackingAuthorizationEventCopyWith(TrackingAuthorizationEvent value,
          $Res Function(TrackingAuthorizationEvent) then) =
      _$TrackingAuthorizationEventCopyWithImpl<$Res,
          TrackingAuthorizationEvent>;
}

/// @nodoc
class _$TrackingAuthorizationEventCopyWithImpl<$Res,
        $Val extends TrackingAuthorizationEvent>
    implements $TrackingAuthorizationEventCopyWith<$Res> {
  _$TrackingAuthorizationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CheckTrackingStatusImplCopyWith<$Res> {
  factory _$$CheckTrackingStatusImplCopyWith(_$CheckTrackingStatusImpl value,
          $Res Function(_$CheckTrackingStatusImpl) then) =
      __$$CheckTrackingStatusImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckTrackingStatusImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationEventCopyWithImpl<$Res,
        _$CheckTrackingStatusImpl>
    implements _$$CheckTrackingStatusImplCopyWith<$Res> {
  __$$CheckTrackingStatusImplCopyWithImpl(_$CheckTrackingStatusImpl _value,
      $Res Function(_$CheckTrackingStatusImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CheckTrackingStatusImpl implements _CheckTrackingStatus {
  const _$CheckTrackingStatusImpl();

  @override
  String toString() {
    return 'TrackingAuthorizationEvent.checkTrackingStatus()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CheckTrackingStatusImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkTrackingStatus,
    required TResult Function() requestTracking,
  }) {
    return checkTrackingStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkTrackingStatus,
    TResult? Function()? requestTracking,
  }) {
    return checkTrackingStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkTrackingStatus,
    TResult Function()? requestTracking,
    required TResult orElse(),
  }) {
    if (checkTrackingStatus != null) {
      return checkTrackingStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CheckTrackingStatus value) checkTrackingStatus,
    required TResult Function(_RequestTracking value) requestTracking,
  }) {
    return checkTrackingStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult? Function(_RequestTracking value)? requestTracking,
  }) {
    return checkTrackingStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult Function(_RequestTracking value)? requestTracking,
    required TResult orElse(),
  }) {
    if (checkTrackingStatus != null) {
      return checkTrackingStatus(this);
    }
    return orElse();
  }
}

abstract class _CheckTrackingStatus implements TrackingAuthorizationEvent {
  const factory _CheckTrackingStatus() = _$CheckTrackingStatusImpl;
}

/// @nodoc
abstract class _$$RequestTrackingImplCopyWith<$Res> {
  factory _$$RequestTrackingImplCopyWith(_$RequestTrackingImpl value,
          $Res Function(_$RequestTrackingImpl) then) =
      __$$RequestTrackingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RequestTrackingImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationEventCopyWithImpl<$Res,
        _$RequestTrackingImpl> implements _$$RequestTrackingImplCopyWith<$Res> {
  __$$RequestTrackingImplCopyWithImpl(
      _$RequestTrackingImpl _value, $Res Function(_$RequestTrackingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RequestTrackingImpl implements _RequestTracking {
  const _$RequestTrackingImpl();

  @override
  String toString() {
    return 'TrackingAuthorizationEvent.requestTracking()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RequestTrackingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkTrackingStatus,
    required TResult Function() requestTracking,
  }) {
    return requestTracking();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkTrackingStatus,
    TResult? Function()? requestTracking,
  }) {
    return requestTracking?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkTrackingStatus,
    TResult Function()? requestTracking,
    required TResult orElse(),
  }) {
    if (requestTracking != null) {
      return requestTracking();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CheckTrackingStatus value) checkTrackingStatus,
    required TResult Function(_RequestTracking value) requestTracking,
  }) {
    return requestTracking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult? Function(_RequestTracking value)? requestTracking,
  }) {
    return requestTracking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CheckTrackingStatus value)? checkTrackingStatus,
    TResult Function(_RequestTracking value)? requestTracking,
    required TResult orElse(),
  }) {
    if (requestTracking != null) {
      return requestTracking(this);
    }
    return orElse();
  }
}

abstract class _RequestTracking implements TrackingAuthorizationEvent {
  const factory _RequestTracking() = _$RequestTrackingImpl;
}

/// @nodoc
mixin _$TrackingAuthorizationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(TrackingStatusEntity trackingStatusEntity)
        maybeAuthorizedTracking,
    required TResult Function(TrackingStatusFailure trackingStatusFailure)
        cannotAuthorizeTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult? Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Processing value) processing,
    required TResult Function(_MaybeAuthorizedTracking value)
        maybeAuthorizedTracking,
    required TResult Function(_CannotAuthorizeTracking value)
        cannotAuthorizeTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Processing value)? processing,
    TResult? Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult? Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Processing value)? processing,
    TResult Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrackingAuthorizationStateCopyWith<$Res> {
  factory $TrackingAuthorizationStateCopyWith(TrackingAuthorizationState value,
          $Res Function(TrackingAuthorizationState) then) =
      _$TrackingAuthorizationStateCopyWithImpl<$Res,
          TrackingAuthorizationState>;
}

/// @nodoc
class _$TrackingAuthorizationStateCopyWithImpl<$Res,
        $Val extends TrackingAuthorizationState>
    implements $TrackingAuthorizationStateCopyWith<$Res> {
  _$TrackingAuthorizationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'TrackingAuthorizationState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(TrackingStatusEntity trackingStatusEntity)
        maybeAuthorizedTracking,
    required TResult Function(TrackingStatusFailure trackingStatusFailure)
        cannotAuthorizeTracking,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult? Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Processing value) processing,
    required TResult Function(_MaybeAuthorizedTracking value)
        maybeAuthorizedTracking,
    required TResult Function(_CannotAuthorizeTracking value)
        cannotAuthorizeTracking,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Processing value)? processing,
    TResult? Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult? Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Processing value)? processing,
    TResult Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements TrackingAuthorizationState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$ProcessingImplCopyWith<$Res> {
  factory _$$ProcessingImplCopyWith(
          _$ProcessingImpl value, $Res Function(_$ProcessingImpl) then) =
      __$$ProcessingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProcessingImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationStateCopyWithImpl<$Res, _$ProcessingImpl>
    implements _$$ProcessingImplCopyWith<$Res> {
  __$$ProcessingImplCopyWithImpl(
      _$ProcessingImpl _value, $Res Function(_$ProcessingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProcessingImpl implements _Processing {
  const _$ProcessingImpl();

  @override
  String toString() {
    return 'TrackingAuthorizationState.processing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProcessingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(TrackingStatusEntity trackingStatusEntity)
        maybeAuthorizedTracking,
    required TResult Function(TrackingStatusFailure trackingStatusFailure)
        cannotAuthorizeTracking,
  }) {
    return processing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult? Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
  }) {
    return processing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Processing value) processing,
    required TResult Function(_MaybeAuthorizedTracking value)
        maybeAuthorizedTracking,
    required TResult Function(_CannotAuthorizeTracking value)
        cannotAuthorizeTracking,
  }) {
    return processing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Processing value)? processing,
    TResult? Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult? Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
  }) {
    return processing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Processing value)? processing,
    TResult Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing(this);
    }
    return orElse();
  }
}

abstract class _Processing implements TrackingAuthorizationState {
  const factory _Processing() = _$ProcessingImpl;
}

/// @nodoc
abstract class _$$MaybeAuthorizedTrackingImplCopyWith<$Res> {
  factory _$$MaybeAuthorizedTrackingImplCopyWith(
          _$MaybeAuthorizedTrackingImpl value,
          $Res Function(_$MaybeAuthorizedTrackingImpl) then) =
      __$$MaybeAuthorizedTrackingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TrackingStatusEntity trackingStatusEntity});
}

/// @nodoc
class __$$MaybeAuthorizedTrackingImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationStateCopyWithImpl<$Res,
        _$MaybeAuthorizedTrackingImpl>
    implements _$$MaybeAuthorizedTrackingImplCopyWith<$Res> {
  __$$MaybeAuthorizedTrackingImplCopyWithImpl(
      _$MaybeAuthorizedTrackingImpl _value,
      $Res Function(_$MaybeAuthorizedTrackingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingStatusEntity = null,
  }) {
    return _then(_$MaybeAuthorizedTrackingImpl(
      trackingStatusEntity: null == trackingStatusEntity
          ? _value.trackingStatusEntity
          : trackingStatusEntity // ignore: cast_nullable_to_non_nullable
              as TrackingStatusEntity,
    ));
  }
}

/// @nodoc

class _$MaybeAuthorizedTrackingImpl implements _MaybeAuthorizedTracking {
  const _$MaybeAuthorizedTrackingImpl({required this.trackingStatusEntity});

  @override
  final TrackingStatusEntity trackingStatusEntity;

  @override
  String toString() {
    return 'TrackingAuthorizationState.maybeAuthorizedTracking(trackingStatusEntity: $trackingStatusEntity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaybeAuthorizedTrackingImpl &&
            (identical(other.trackingStatusEntity, trackingStatusEntity) ||
                other.trackingStatusEntity == trackingStatusEntity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, trackingStatusEntity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaybeAuthorizedTrackingImplCopyWith<_$MaybeAuthorizedTrackingImpl>
      get copyWith => __$$MaybeAuthorizedTrackingImplCopyWithImpl<
          _$MaybeAuthorizedTrackingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(TrackingStatusEntity trackingStatusEntity)
        maybeAuthorizedTracking,
    required TResult Function(TrackingStatusFailure trackingStatusFailure)
        cannotAuthorizeTracking,
  }) {
    return maybeAuthorizedTracking(trackingStatusEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult? Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
  }) {
    return maybeAuthorizedTracking?.call(trackingStatusEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (maybeAuthorizedTracking != null) {
      return maybeAuthorizedTracking(trackingStatusEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Processing value) processing,
    required TResult Function(_MaybeAuthorizedTracking value)
        maybeAuthorizedTracking,
    required TResult Function(_CannotAuthorizeTracking value)
        cannotAuthorizeTracking,
  }) {
    return maybeAuthorizedTracking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Processing value)? processing,
    TResult? Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult? Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
  }) {
    return maybeAuthorizedTracking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Processing value)? processing,
    TResult Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (maybeAuthorizedTracking != null) {
      return maybeAuthorizedTracking(this);
    }
    return orElse();
  }
}

abstract class _MaybeAuthorizedTracking implements TrackingAuthorizationState {
  const factory _MaybeAuthorizedTracking(
          {required final TrackingStatusEntity trackingStatusEntity}) =
      _$MaybeAuthorizedTrackingImpl;

  TrackingStatusEntity get trackingStatusEntity;
  @JsonKey(ignore: true)
  _$$MaybeAuthorizedTrackingImplCopyWith<_$MaybeAuthorizedTrackingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CannotAuthorizeTrackingImplCopyWith<$Res> {
  factory _$$CannotAuthorizeTrackingImplCopyWith(
          _$CannotAuthorizeTrackingImpl value,
          $Res Function(_$CannotAuthorizeTrackingImpl) then) =
      __$$CannotAuthorizeTrackingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TrackingStatusFailure trackingStatusFailure});
}

/// @nodoc
class __$$CannotAuthorizeTrackingImplCopyWithImpl<$Res>
    extends _$TrackingAuthorizationStateCopyWithImpl<$Res,
        _$CannotAuthorizeTrackingImpl>
    implements _$$CannotAuthorizeTrackingImplCopyWith<$Res> {
  __$$CannotAuthorizeTrackingImplCopyWithImpl(
      _$CannotAuthorizeTrackingImpl _value,
      $Res Function(_$CannotAuthorizeTrackingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingStatusFailure = null,
  }) {
    return _then(_$CannotAuthorizeTrackingImpl(
      trackingStatusFailure: null == trackingStatusFailure
          ? _value.trackingStatusFailure
          : trackingStatusFailure // ignore: cast_nullable_to_non_nullable
              as TrackingStatusFailure,
    ));
  }
}

/// @nodoc

class _$CannotAuthorizeTrackingImpl implements _CannotAuthorizeTracking {
  const _$CannotAuthorizeTrackingImpl({required this.trackingStatusFailure});

  @override
  final TrackingStatusFailure trackingStatusFailure;

  @override
  String toString() {
    return 'TrackingAuthorizationState.cannotAuthorizeTracking(trackingStatusFailure: $trackingStatusFailure)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CannotAuthorizeTrackingImpl &&
            (identical(other.trackingStatusFailure, trackingStatusFailure) ||
                other.trackingStatusFailure == trackingStatusFailure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, trackingStatusFailure);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CannotAuthorizeTrackingImplCopyWith<_$CannotAuthorizeTrackingImpl>
      get copyWith => __$$CannotAuthorizeTrackingImplCopyWithImpl<
          _$CannotAuthorizeTrackingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(TrackingStatusEntity trackingStatusEntity)
        maybeAuthorizedTracking,
    required TResult Function(TrackingStatusFailure trackingStatusFailure)
        cannotAuthorizeTracking,
  }) {
    return cannotAuthorizeTracking(trackingStatusFailure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult? Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
  }) {
    return cannotAuthorizeTracking?.call(trackingStatusFailure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(TrackingStatusEntity trackingStatusEntity)?
        maybeAuthorizedTracking,
    TResult Function(TrackingStatusFailure trackingStatusFailure)?
        cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (cannotAuthorizeTracking != null) {
      return cannotAuthorizeTracking(trackingStatusFailure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Processing value) processing,
    required TResult Function(_MaybeAuthorizedTracking value)
        maybeAuthorizedTracking,
    required TResult Function(_CannotAuthorizeTracking value)
        cannotAuthorizeTracking,
  }) {
    return cannotAuthorizeTracking(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Processing value)? processing,
    TResult? Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult? Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
  }) {
    return cannotAuthorizeTracking?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Processing value)? processing,
    TResult Function(_MaybeAuthorizedTracking value)? maybeAuthorizedTracking,
    TResult Function(_CannotAuthorizeTracking value)? cannotAuthorizeTracking,
    required TResult orElse(),
  }) {
    if (cannotAuthorizeTracking != null) {
      return cannotAuthorizeTracking(this);
    }
    return orElse();
  }
}

abstract class _CannotAuthorizeTracking implements TrackingAuthorizationState {
  const factory _CannotAuthorizeTracking(
          {required final TrackingStatusFailure trackingStatusFailure}) =
      _$CannotAuthorizeTrackingImpl;

  TrackingStatusFailure get trackingStatusFailure;
  @JsonKey(ignore: true)
  _$$CannotAuthorizeTrackingImplCopyWith<_$CannotAuthorizeTrackingImpl>
      get copyWith => throw _privateConstructorUsedError;
}
